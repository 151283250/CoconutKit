//
//  NSManagedObject+HLSExtensions.m
//  CoconutKit
//
//  Created by Samuel DÃ©fago on 21.10.11.
//  Copyright (c) 2011 Hortis. All rights reserved.
//

#import "NSManagedObject+HLSExtensions.h"

#import "HLSLogger.h"
#import "HLSModelManager.h"
#import "NSObject+HLSExtensions.h"

#import <objc/runtime.h>

static BOOL validateProperty(id self, SEL sel, id *pValue, NSError **pError);
static BOOL validateForConsistency(id self, SEL sel, NSError **pError);
static BOOL validateForDelete(id self, SEL sel, NSError **pError);
static BOOL validateObject(id self, SEL sel, NSError **pError);

@implementation NSManagedObject (HLSExtensions)

+ (id)insertIntoManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    return [NSEntityDescription insertNewObjectForEntityForName:[self className] inManagedObjectContext:managedObjectContext];
}

+ (id)insert
{
    return [self insertIntoManagedObjectContext:[HLSModelManager defaultModelContext]];
}

+ (NSArray *)filteredObjectsUsingPredicate:(NSPredicate *)predicate
                    sortedUsingDescriptors:(NSArray *)sortDescriptors
                    inManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    NSEntityDescription *entityDescription = [NSEntityDescription entityForName:[self className]
                                                         inManagedObjectContext:managedObjectContext];
    NSFetchRequest *fetchRequest = [[[NSFetchRequest alloc] init] autorelease];
    [fetchRequest setEntity:entityDescription];
    fetchRequest.sortDescriptors = sortDescriptors;
    fetchRequest.predicate = predicate;
    
    NSError *error = nil;
    NSArray *objects = [managedObjectContext executeFetchRequest:fetchRequest error:&error];
    if (error) {
        HLSLoggerError(@"Could not retrieve objects; reason: %@", error);
        return nil;
    }
    
    return objects;
}

+ (NSArray *)filteredObjectsUsingPredicate:(NSPredicate *)predicate
                    sortedUsingDescriptors:(NSArray *)sortDescriptors
{
    return [self filteredObjectsUsingPredicate:predicate
                        sortedUsingDescriptors:sortDescriptors 
                        inManagedObjectContext:[HLSModelManager defaultModelContext]];
}

+ (NSArray *)allObjectsSortedUsingDescriptors:(NSArray *)sortDescriptors
                       inManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    return [self filteredObjectsUsingPredicate:nil 
                        sortedUsingDescriptors:sortDescriptors 
                        inManagedObjectContext:managedObjectContext];
}

+ (NSArray *)allObjectsSortedUsingDescriptors:(NSArray *)sortDescriptors
{
    return [self allObjectsSortedUsingDescriptors:sortDescriptors inManagedObjectContext:[HLSModelManager defaultModelContext]];
}

+ (NSArray *)allObjectsInManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    return [self allObjectsSortedUsingDescriptors:nil 
                           inManagedObjectContext:managedObjectContext];
}

+ (NSArray *)allObjects
{
    return [self allObjectsInManagedObjectContext:[HLSModelManager defaultModelContext]];
}

#pragma mark Global validation method stubs

- (BOOL)checkForConsistency:(NSError **)pError
{
    return YES;
}

- (BOOL)checkForDelete:(NSError **)pError
{
    return YES;
}

@end

@implementation NSManagedObject (HLSExtensionsPrivate)

+ (void)initialize
{
    // No class identity test here. This must be executed for all objects in the hierarchy rooted at NSManagedObject, so that we can
    // locate the @dynamic properties we are interested in (those which need validation)
    
    unsigned int numberOfProperties = 0;
    objc_property_t *properties = class_copyPropertyList(self, &numberOfProperties);
    BOOL added = NO;
    for (unsigned int i = 0; i < numberOfProperties; ++i) {
        objc_property_t property = properties[i];
        
        // Only dynamic properties (i.e. properties generated by Core Data)
        NSArray *attributes = [[NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding] componentsSeparatedByString:@","];
        if (! [attributes containsObject:@"D"]) {
            continue;
        }
        
        NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
        if ([propertyName length] == 0) {
            HLSLoggerError(@"Missing property name");
            continue;
        }
        
        NSString *validationSelectorName = [NSString stringWithFormat:@"validate%@%@:error:", [[propertyName substringToIndex:1] uppercaseString], 
                                            [propertyName substringFromIndex:1]];
        NSString *types = [NSString stringWithFormat:@"%s%s%s%s%s", @encode(BOOL), @encode(id), @encode(SEL), @encode(id *), @encode(id *)];
        if (! class_addMethod(self, 
                              NSSelectorFromString(validationSelectorName),         // Remark: (SEL)[validationSelectorName cStringUsingEncoding:NSUTF8StringEncoding] does NOT work (returns YES, but IMP does not get called)
                              (IMP)validateProperty, 
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add %@ method dynamically", validationSelectorName);
            continue;
        }
        
        HLSLoggerDebug(@"Automatically added validation wrapper %@ on class %@", validationSelectorName, self);
        
        added = YES;
    }
    free(properties);
    
    // If a validation method was injected, we must also inject global validations
    if (added) {
        NSString *types = [NSString stringWithFormat:@"%s%s%s%s", @encode(BOOL), @encode(id), @encode(SEL), @encode(id *)];
        if (! class_addMethod(self, 
                              @selector(validateForInsert:), 
                              (IMP)validateForConsistency,
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add validateForInsert: method dynamically");
        }
        if (! class_addMethod(self, 
                              @selector(validateForUpdate:), 
                              (IMP)validateForConsistency,
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add validateForUpdate: method dynamically");
        }        
        if (! class_addMethod(self, 
                              @selector(validateForDelete:), 
                              (IMP)validateForDelete,
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add validateForDelete: method dynamically");
        }
    }
}

@end

static BOOL validateProperty(id self, SEL sel, id *pValue, NSError **pError)
{
    // Try to locate a check method. If none is found, the value is always valid
    NSString *selectorName = [NSString stringWithCString:(char *)sel encoding:NSUTF8StringEncoding];
    NSString *checkSelectorName = [selectorName stringByReplacingOccurrencesOfString:@"validate" withString:@"check"];
    SEL checkSel = NSSelectorFromString(checkSelectorName);
    if (! [self respondsToSelector:checkSel]) {
        return YES;
    }
    
    // Call the check method
    id value = pValue ? *pValue : nil;
    BOOL (*checkImp)(id, SEL, id, NSError **) = (BOOL (*)(id, SEL, id, NSError **))class_getMethodImplementation([self class], checkSel);
    return (*checkImp)(self, checkSel, value, pError);
    
    // TODO: Chain errors; Core Data namely performs all validations, even if one fails, when the object is saved
}

static BOOL validateForConsistency(id self, SEL sel, NSError **pError)
{
    return validateObject(self, @selector(checkForConsistency:), pError);
}

static BOOL validateForDelete(id self, SEL sel, NSError **pError)
{
    return validateObject(self, @selector(checkForDelete:), pError);
}

static BOOL validateObject(id self, SEL sel, NSError **pError)
{
    BOOL (*checkImp)(id, SEL, NSError **) = (BOOL (*)(id, SEL, NSError **))class_getMethodImplementation([self class], sel);
    return (*checkImp)(self, sel, pError);
    
    // TODO: Chain errors with those stemming from super (to be called first)
}
