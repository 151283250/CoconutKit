//
//  NSManagedObject+HLSExtensions.m
//  CoconutKit
//
//  Created by Samuel DÃ©fago on 21.10.11.
//  Copyright (c) 2011 Hortis. All rights reserved.
//

#import "NSManagedObject+HLSExtensions.h"

#import "HLSLogger.h"
#import "HLSModelManager.h"
#import "NSObject+HLSExtensions.h"

#import <objc/runtime.h>

static SEL checkSelectorForValidationSelector(SEL sel);
static BOOL validateProperty(id self, SEL sel, id *pValue, NSError **pError);
static BOOL validateObjectConsistency(id self, SEL sel, NSError **pError);
static BOOL validateObjectConsistencyInClassHierarchy(id self, Class class, SEL sel, NSError **pError);
static BOOL validateForDelete(id self, SEL sel, NSError **pError);

@implementation NSManagedObject (HLSExtensions)

+ (id)insertIntoManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    return [NSEntityDescription insertNewObjectForEntityForName:[self className] inManagedObjectContext:managedObjectContext];
}

+ (id)insert
{
    return [self insertIntoManagedObjectContext:[HLSModelManager defaultModelContext]];
}

+ (NSArray *)filteredObjectsUsingPredicate:(NSPredicate *)predicate
                    sortedUsingDescriptors:(NSArray *)sortDescriptors
                    inManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    NSEntityDescription *entityDescription = [NSEntityDescription entityForName:[self className]
                                                         inManagedObjectContext:managedObjectContext];
    NSFetchRequest *fetchRequest = [[[NSFetchRequest alloc] init] autorelease];
    [fetchRequest setEntity:entityDescription];
    fetchRequest.sortDescriptors = sortDescriptors;
    fetchRequest.predicate = predicate;
    
    NSError *error = nil;
    NSArray *objects = [managedObjectContext executeFetchRequest:fetchRequest error:&error];
    if (error) {
        HLSLoggerError(@"Could not retrieve objects; reason: %@", error);
        return nil;
    }
    
    return objects;
}

+ (NSArray *)filteredObjectsUsingPredicate:(NSPredicate *)predicate
                    sortedUsingDescriptors:(NSArray *)sortDescriptors
{
    return [self filteredObjectsUsingPredicate:predicate
                        sortedUsingDescriptors:sortDescriptors 
                        inManagedObjectContext:[HLSModelManager defaultModelContext]];
}

+ (NSArray *)allObjectsSortedUsingDescriptors:(NSArray *)sortDescriptors
                       inManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    return [self filteredObjectsUsingPredicate:nil 
                        sortedUsingDescriptors:sortDescriptors 
                        inManagedObjectContext:managedObjectContext];
}

+ (NSArray *)allObjectsSortedUsingDescriptors:(NSArray *)sortDescriptors
{
    return [self allObjectsSortedUsingDescriptors:sortDescriptors inManagedObjectContext:[HLSModelManager defaultModelContext]];
}

+ (NSArray *)allObjectsInManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    return [self allObjectsSortedUsingDescriptors:nil 
                           inManagedObjectContext:managedObjectContext];
}

+ (NSArray *)allObjects
{
    return [self allObjectsInManagedObjectContext:[HLSModelManager defaultModelContext]];
}

#pragma mark Global validation method stubs

- (BOOL)checkForConsistency:(NSError **)pError
{
    return YES;
}

- (BOOL)checkForDelete:(NSError **)pError
{
    return YES;
}

@end

@implementation NSManagedObject (HLSExtensionsPrivate)

+ (void)initialize
{
    // No class identity test here. This must be executed for all objects in the hierarchy rooted at NSManagedObject, so that we can
    // locate the @dynamic properties we are interested in (those which need validation)
    
    unsigned int numberOfProperties = 0;
    objc_property_t *properties = class_copyPropertyList(self, &numberOfProperties);
    BOOL added = NO;
    for (unsigned int i = 0; i < numberOfProperties; ++i) {
        objc_property_t property = properties[i];
        
        // Only dynamic properties (i.e. properties generated by Core Data)
        NSArray *attributes = [[NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding] componentsSeparatedByString:@","];
        if (! [attributes containsObject:@"D"]) {
            continue;
        }
        
        NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
        if ([propertyName length] == 0) {
            HLSLoggerError(@"Missing property name");
            continue;
        }
        
        NSString *validationSelectorName = [NSString stringWithFormat:@"validate%@%@:error:", [[propertyName substringToIndex:1] uppercaseString], 
                                            [propertyName substringFromIndex:1]];
        NSString *types = [NSString stringWithFormat:@"%s%s%s%s%s", @encode(BOOL), @encode(id), @encode(SEL), @encode(id *), @encode(id *)];
        if (! class_addMethod(self, 
                              NSSelectorFromString(validationSelectorName),         // Remark: (SEL)[validationSelectorName cStringUsingEncoding:NSUTF8StringEncoding] does NOT work (returns YES, but IMP does not get called)
                              (IMP)validateProperty, 
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add %@ method dynamically", validationSelectorName);
            continue;
        }
        
        HLSLoggerDebug(@"Automatically added validation wrapper %@ on class %@", validationSelectorName, self);
        
        added = YES;
    }
    free(properties);
    
    // If a validation method was injected, we must also inject global validations
    if (added) {
        NSString *types = [NSString stringWithFormat:@"%s%s%s%s", @encode(BOOL), @encode(id), @encode(SEL), @encode(id *)];
        if (! class_addMethod(self, 
                              @selector(validateForInsert:), 
                              (IMP)validateObjectConsistency,
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add validateForInsert: method dynamically");
        }
        if (! class_addMethod(self, 
                              @selector(validateForUpdate:), 
                              (IMP)validateObjectConsistency,
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add validateForUpdate: method dynamically");
        }        
        if (! class_addMethod(self, 
                              @selector(validateForDelete:), 
                              (IMP)validateObjectConsistency,
                              [types cStringUsingEncoding:NSUTF8StringEncoding])) {
            HLSLoggerError(@"Failed to add validateForDelete: method dynamically");
        }
    }
}

@end

/**
 * Return the check selector associated with a validation selector
 */
static SEL checkSelectorForValidationSelector(SEL sel)
{
    // The check method bears the same name as the validation method, but beginning with "check"
    NSString *selectorName = [NSString stringWithCString:(char *)sel encoding:NSUTF8StringEncoding];
    NSString *checkSelectorName = [selectorName stringByReplacingOccurrencesOfString:@"validate" withString:@"check"];
    return  NSSelectorFromString(checkSelectorName);
}

/**
 * Implementation common to all injected single validation methods (validate<FieldName>:error:)
 *
 * This implementation calls the underlying check method and performs Core Data error chaining
 */
static BOOL validateProperty(id self, SEL sel, id *pValue, NSError **pError)
{
    // TODO: Chain errors; Core Data namely performs all validations, even if one fails, when the object is saved
        
    // If the method does not exist, valid
    SEL checkSel = checkSelectorForValidationSelector(sel);
    Method method = class_getInstanceMethod([self class], checkSel);
    if (! method) {
        return YES;
    }
    
    // Call the check method
    id value = pValue ? *pValue : nil;
    BOOL (*checkImp)(id, SEL, id, NSError **) = (BOOL (*)(id, SEL, id, NSError **))method_getImplementation(method);
    return (*checkImp)(self, checkSel, value, pError);
}

/**
 * Implementation common to all injected global validation methods:
 *   -[NSManagedObject validateForInsert:]
 *   -[NSManagedObject validateForUpdate:]
 *   -[NSManagedObject validateForDelete:]
 *
 * This implementation calls the underlying check methods, performs Core Data error chaining, and ensures that these methods 
 * get consistently called along the inheritance hierarchy. This is strongly recommended by the Core Data documentation, and
 * in fact failing to do so leads to undefined behavior: The -[NSManagedObject validateForUpdate:] and 
 * -[NSManagedObject validateForInsert:] methods are namely where individual validations are called! If those were not
 * called, individual validations would not be called either!
 */
static BOOL validateObjectConsistency(id self, SEL sel, NSError **pError)
{
    return validateObjectConsistencyInClassHierarchy(self, [self class], sel, pError);
}

/**
 * Validate the consistency of self, applying to it the sel defined for the class given as parameter. This methods can
 * therefore be used to check global object consistency at all levels of the managed object inheritance hierarchy
 */
static BOOL validateObjectConsistencyInClassHierarchy(id self, Class class, SEL sel, NSError **pError)
{    
    // TODO: Chain errors
    
    if (class == [NSManagedObject class]) {
        // These implementations exist, no need to test if respondsToSelector:
        BOOL (*imp)(id, SEL, NSError **) = (BOOL (*)(id, SEL, NSError **))class_getMethodImplementation(class, sel);
        return (*imp)(self, sel, pError);
    }
    else {
        // Climb up the inheritance hierarchy
        BOOL valid = YES;
        if (! validateObjectConsistencyInClassHierarchy(self, class_getSuperclass(class), sel, pError)) {
            valid = NO;
        }
        
        // If no check method has been defined at this level, valid (i.e. does not alter the above
        // validation status)
        SEL checkSel = checkSelectorForValidationSelector(sel);
        Method method = class_getInstanceMethod(class, checkSel);
        if (! method) {
            return valid;
        }
        
        // Call the underlying check method implementation
        BOOL (*checkImp)(id, SEL, NSError **) = (BOOL (*)(id, SEL, NSError **))method_getImplementation(method);
        if (! (*checkImp)(self, checkSel, pError)) {
            return NO;
        }
        
        return valid;
    }
}

